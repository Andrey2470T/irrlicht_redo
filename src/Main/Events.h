#pragma once

#include "BasicIncludes.h"
#include "Keycodes.h"
#include <string.h>
#include "LogStream.h"

namespace main
{

//! Enumeration for all event types there are.
enum EventType
{
	ET_MOUSE_INPUT_EVENT = 1,
	ET_KEY_INPUT_EVENT,
	ET_STRING_INPUT_EVENT,
	ET_TOUCH_INPUT_EVENT,
	ET_ACCELEROMETER_EVENT,
	ET_GYROSCOPE_EVENT,
	ET_JOYSTICK_INPUT_EVENT,
    ET_LOG_TEXT_EVENT,
	ET_USER_EVENT,
    ET_APPLICATION_EVENT,
	GUIET_FORCE_32_BIT = 0x7fffffff
};

//! Enumeration for all mouse input events
enum MouseInputEventType
{
	MIE_LMOUSE_PRESSED_DOWN = 0,
	MIE_RMOUSE_PRESSED_DOWN,
	MIE_MMOUSE_PRESSED_DOWN,
	MIE_LMOUSE_LEFT_UP,
	MIE_RMOUSE_LEFT_UP,
	MIE_MMOUSE_LEFT_UP,
	MIE_MOUSE_MOVED,
	MIE_MOUSE_WHEEL,
	MIE_LMOUSE_DOUBLE_CLICK,
	MIE_RMOUSE_DOUBLE_CLICK,
	MIE_MMOUSE_DOUBLE_CLICK,
	MIE_LMOUSE_TRIPLE_CLICK,
	MIE_RMOUSE_TRIPLE_CLICK,
	MIE_MMOUSE_TRIPLE_CLICK,
	//! Mouse enters canvas used for rendering.
	//! Only generated on emscripten
	MIE_MOUSE_ENTER_CANVAS,
	//! Mouse leaves canvas used for rendering.
	//! Only generated on emscripten
	MIE_MOUSE_LEAVE_CANVAS,
	//! No real event. Just for convenience to get number of events
	MIE_COUNT
};

//! Masks for mouse button states
enum MouseButtonStateMask
{
	MBSM_LEFT = 0x01,
	MBSM_RIGHT = 0x02,
	MBSM_MIDDLE = 0x04,
	//! currently only on windows
	MBSM_EXTRA1 = 0x08,
	//! currently only on windows
	MBSM_EXTRA2 = 0x10,

	MBSM_FORCE_32_BIT = 0x7fffffff
};

//! Enumeration for all touch input events
enum TouchInputEventType
{
	TIE_PRESSED_DOWN = 0,
	TIE_LEFT_UP,
	TIE_MOVED,
	//! No real event. Just for convenience to get number of events
	TIE_COUNT
};

//! Enumeration for a commonly used application state events (it's useful mainly for mobile devices)
enum ApplicationEventType
{
	AET_WILL_RESUME = 0,
	AET_DID_RESUME,
	AET_WILL_PAUSE,
	AET_DID_PAUSE,
	AET_WILL_TERMINATE,
	AET_MEMORY_WARNING,
	AET_DPI_CHANGED,
	//! No real event, but to get number of event types.
	AET_COUNT
};

//! Holds information about an event
struct Event
{
	//! Any kind of mouse event.
	struct MouseInputEvent
	{
		//! X position of mouse cursor
		s32 X;
		//! Y position of mouse cursor
		s32 Y;

		//! mouse wheel delta, often 1.0 or -1.0, but can have other values < 0.f or > 0.f;
		/** Only valid if event was EMIE_MOUSE_WHEEL */
		f32 WheelDelta;

		//! True if shift was also pressed
		bool Shift : 1;

		//! True if ctrl was also pressed
		bool Control : 1;

		//! Is this a simulated mouse event generated by the engine itself?
		bool Simulated : 1;

		//! A bitmap of button states. You can use isButtonPressed() to determine
		//! if a button is pressed or not.
		u32 ButtonStates;

		//! Is the left button pressed down?
		bool isLeftPressed() const { return 0 != (ButtonStates & MBSM_LEFT); }

		//! Is the right button pressed down?
		bool isRightPressed() const { return 0 != (ButtonStates & MBSM_RIGHT); }

		//! Is the middle button pressed down?
		bool isMiddlePressed() const { return 0 != (ButtonStates & MBSM_MIDDLE); }

		//! Type of mouse event
		MouseInputEventType Type;
	};

	//! Any kind of keyboard event.
	struct KeyInputEvent
	{
		//! Character corresponding to the key (0, if not a character, value undefined in key releases)
		wchar_t Char;

		//! Key which has been pressed or released
		KEY_CODE Key;

		//! System dependent code. Only set for systems which are described below, otherwise undefined.
		//! Android: int32_t with physical key as returned by AKeyEvent_getKeyCode
		u32 SystemKeyCode;

		//! If not true, then the key was left up
		bool PressedDown : 1;

		//! True if shift was also pressed
		bool Shift : 1;

		//! True if ctrl was also pressed
		bool Control : 1;
	};

	//! String input event.
	struct StringInputEvent
	{
		//! The string that is entered
        wchar_t *Str;
	};

	//! Any kind of touch event.
	struct TouchInputEvent
	{
		// Touch ID.
		size_t ID;

		// X position of simple touch.
		s32 X;
		// Y position of simple touch.
		s32 Y;

		// number of current touches
		s32 touchedCount;

		//! Type of touch event.
		TouchInputEventType Type;
	};

	//! Any kind of accelerometer event.
	struct AccelerometerEvent
	{
		// X acceleration.
		f64 X;
		// Y acceleration.
		f64 Y;
		// Z acceleration.
		f64 Z;
	};

	//! Any kind of gyroscope event.
	struct GyroscopeEvent
	{
		// X rotation.
		f64 X;
		// Y rotation.
		f64 Y;
		// Z rotation.
		f64 Z;
	};

	//! Any kind of device motion event.
	struct DeviceMotionEvent
	{
		// X angle - roll.
		f64 X;
		// Y angle - pitch.
		f64 Y;
		// Z angle - yaw.
		f64 Z;
	};

	//! A joystick event.
	/** Unlike other events, joystick events represent the result of polling
	 * each connected joystick once per run() of the device. Joystick events will
	 * not be generated by default.  If joystick support is available for the
	 * active device, and @ref irr::IrrlichtDevice::activateJoysticks() has been
	 * called, an event of this type will be generated once per joystick per
	 * @ref IrrlichtDevice::run() regardless of whether the state of the joystick
	 * has actually changed. */
	struct JoystickEvent
	{
		enum
		{
			NUMBER_OF_BUTTONS = 32,

			AXIS_X = 0, // e.g. analog stick 1 left to right
			AXIS_Y,     // e.g. analog stick 1 top to bottom
			AXIS_Z,     // e.g. throttle, or analog 2 stick 2 left to right
			AXIS_R,     // e.g. rudder, or analog 2 stick 2 top to bottom
			AXIS_U,
			AXIS_V,
			NUMBER_OF_AXES = 18 // (please tell Irrlicht maintainers if you absolutely need more axes)
		};

		/** A bitmap of button states.  You can use IsButtonPressed() to
		 ( check the state of each button from 0 to (NUMBER_OF_BUTTONS - 1) */
		u32 ButtonStates;

		/** For AXIS_X, AXIS_Y, AXIS_Z, AXIS_R, AXIS_U and AXIS_V
		 * Values are in the range -32768 to 32767, with 0 representing
		 * the center position.  You will receive the raw value from the
		 * joystick, and so will usually want to implement a dead zone around
		 * the center of the range. Axes not supported by this joystick will
		 * always have a value of 0. On Linux, POV hats are represented as axes,
		 * usually the last two active axis.
		 */
		s16 Axis[NUMBER_OF_AXES];

		/** The POV represents the angle of the POV hat in degrees * 100,
		 * from 0 to 35,900.  A value of 65535 indicates that the POV hat
		 * is centered (or not present).
		 * This value is only supported on Windows.  On Linux, the POV hat
		 * will be sent as 2 axes instead. */
		u16 POV;

		//! The ID of the joystick which generated this event.
		/** This is an internal Irrlicht index; it does not map directly
		 * to any particular hardware joystick. */
		u8 Joystick;

		//! A helper function to check if a button is pressed.
		bool IsButtonPressed(u32 button) const
		{
			if (button >= (u32)NUMBER_OF_BUTTONS)
				return false;

			return (ButtonStates & (1 << button)) ? true : false;
		}
	};

	//! Any kind of user event.
	struct UserEvent
	{
		//! Some user specified data as int
		size_t UserData1;
		//! Another user specified data as int
		size_t UserData2;
	};

    struct LogEvent
    {
        //! Pointer to text which has been logged
        const c8 *Text;

        //! Log level in which the text has been logged
        LogLevel Level;
    };

	// Application state event
	struct ApplicationEvent
	{
		ApplicationEventType Type;
	};

	EventType Type;
	union
	{
		struct MouseInputEvent MouseInput;
		struct KeyInputEvent KeyInput;
		struct StringInputEvent StringInput;
		struct TouchInputEvent TouchInput;
		struct AccelerometerEvent Accelerometer;
		struct GyroscopeEvent Gyroscope;
		struct DeviceMotionEvent DeviceMotion;
		struct JoystickEvent Joystick;
        struct LogEvent Log;
		struct UserEvent User;
		struct ApplicationEvent Application;
	};

    Event() {
        Type = static_cast<EventType>(0);
		// zero the biggest union member we have, which clears all others too
		memset(&Joystick, 0, sizeof(Joystick));
	}
    ~Event() {};
};

//! Information on a joystick, returned from @ref irr::IrrlichtDevice::activateJoysticks()
struct JoystickInfo
{
    //! The ID of the joystick
    /** This is an internal Irrlicht index; it does not map directly
     * to any particular hardware joystick. It corresponds to the
     * irr::SJoystickEvent Joystick ID. */
    u8 Joystick;

    //! The name that the joystick uses to identify itself.
    std::string Name;

    //! The number of buttons that the joystick has.
    u32 Buttons;

    //! The number of axes that the joystick has, i.e. X, Y, Z, R, U, V.
    /** Note: with a Linux device, the POV hat (if any) will use two axes. These
     *  will be included in this count. */
    u32 Axes;

    //! An indication of whether the joystick has a POV hat.
    /** A Windows device will identify the presence or absence of the POV hat.
     *  A Linux device cannot, and will always return POV_HAT_UNKNOWN. */
    enum
    {
        //! A hat is definitely present.
        POV_HAT_PRESENT,

        //! A hat is definitely not present.
        POV_HAT_ABSENT,

        //! The presence or absence of a hat cannot be determined.
        POV_HAT_UNKNOWN
    } PovHat;
};

}
